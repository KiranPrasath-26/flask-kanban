"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_js_1 = require("./utils.js");
/**
 * Inject the CSS compiled with JS.
 *
 * @return {Plugin}
 */
function cssInjectedByJsPlugin({ topExecutionPriority, styleId, injectCode, injectCodeFunction, useStrictCSP } = {
    topExecutionPriority: true,
    styleId: '',
}) {
    //Globally so we can add it to legacy and non-legacy bundle.
    let cssToInject = '';
    let config;
    return {
        apply: 'build',
        enforce: 'post',
        name: 'css-in-js-plugin',
        configResolved(_config) {
            config = _config;
        },
        generateBundle(opts, bundle) {
            return __awaiter(this, void 0, void 0, function* () {
                if (config.build.ssr) {
                    return;
                }
                const htmlFiles = Object.keys(bundle).filter((i) => i.endsWith('.html'));
                const cssAssets = Object.keys(bundle).filter((i) => bundle[i].type == 'asset' && bundle[i].fileName.endsWith('.css'));
                const jsAssets = Object.keys(bundle).filter((i) => bundle[i].type == 'chunk' &&
                    // @ts-ignore isEntry is supported by the highest parent of the OutputChunk type
                    bundle[i].isEntry == true &&
                    bundle[i].fileName.match(/.[cm]?js$/) != null &&
                    !bundle[i].fileName.includes('polyfill'));
                const allCssCode = cssAssets.reduce(function extractCssCodeAndDeleteFromBundle(previousValue, cssName) {
                    const cssAsset = bundle[cssName];
                    const cssAssetSource = typeof cssAsset.source == 'string'
                        ? cssAsset.source.replace(/(\r\n|\n|\r)+$/gm, '')
                        : cssAsset.source;
                    const result = previousValue + cssAssetSource;
                    delete bundle[cssName];
                    return result;
                }, '');
                if (allCssCode.length > 0) {
                    cssToInject = allCssCode;
                }
                for (const name of htmlFiles) {
                    const htmlChunk = bundle[name];
                    let replacedHtml = htmlChunk.source;
                    cssAssets.forEach((cssName) => {
                        replacedHtml = (0, utils_js_1.removeLinkStyleSheets)(replacedHtml, cssName);
                        htmlChunk.source = replacedHtml;
                    });
                }
                // This should be always the root of the application
                const jsAsset = bundle[jsAssets[jsAssets.length - 1]];
                const cssInjectionCode = yield (0, utils_js_1.buildCSSInjectionCode)({
                    cssToInject,
                    styleId,
                    injectCode,
                    injectCodeFunction,
                    useStrictCSP,
                });
                const appCode = jsAsset.code;
                jsAsset.code = topExecutionPriority ? '' : appCode;
                jsAsset.code += cssInjectionCode ? cssInjectionCode.code : '';
                jsAsset.code += !topExecutionPriority ? '' : appCode;
            });
        },
    };
}
exports.default = cssInjectedByJsPlugin;
